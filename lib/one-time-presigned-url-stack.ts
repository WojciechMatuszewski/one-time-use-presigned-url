import * as apigw from "@aws-cdk/aws-apigatewayv2";
import * as apigwIntegrations from "@aws-cdk/aws-apigatewayv2-integrations";
import * as cloudfront from "@aws-cdk/aws-cloudfront";
import * as origins from "@aws-cdk/aws-cloudfront-origins";
import * as dynamo from "@aws-cdk/aws-dynamodb";
import * as lambda from "@aws-cdk/aws-lambda-nodejs";
import * as s3 from "@aws-cdk/aws-s3";
import * as cdk from "@aws-cdk/core";
import * as ssm from "@aws-cdk/aws-ssm";
import { join } from "path";

export class OneTimePresignedUrlStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const entriesTable = new dynamo.Table(this, "entriesTable", {
      partitionKey: { name: "pk", type: dynamo.AttributeType.STRING },
      billingMode: dynamo.BillingMode.PAY_PER_REQUEST,
      removalPolicy: cdk.RemovalPolicy.DESTROY
    });
    const bucket = new s3.Bucket(this, "assets-bucket", {
      removalPolicy: cdk.RemovalPolicy.DESTROY
    });

    const urlLambda = new lambda.NodejsFunction(this, "urlLambda", {
      entry: join(__dirname, "./url-lambda.ts"),
      environment: {
        BUCKET_NAME: bucket.bucketName
      }
    });
    bucket.grantRead(urlLambda);

    const api = new apigw.HttpApi(this, "api", {
      corsPreflight: {
        allowMethods: [apigw.CorsHttpMethod.GET]
      }
    });
    api.addRoutes({
      integration: new apigwIntegrations.LambdaProxyIntegration({
        handler: urlLambda
      }),
      path: "/get-url",
      methods: [apigw.HttpMethod.GET]
    });

    /**
     * Lambda@Edge does not support environment variables.
     * To forward the `entriesTable` name generated by CloudFormation,
     * an SSM parameter is created.
     *
     * This parameter will be fetched during the runtime of the `edgeLambda`.
     */
    const entriesTableParameter = new ssm.StringParameter(
      this,
      "URL_ENTRIES_TABLE_NAME",
      {
        stringValue: entriesTable.tableName,
        parameterName: "URL_ENTRIES_TABLE_NAME"
      }
    );

    const edgeLambda = new lambda.NodejsFunction(this, "edgeLambda", {
      entry: join(__dirname, "./edge-lambda.ts")
    });
    entriesTable.grantReadWriteData(edgeLambda.currentVersion);
    entriesTableParameter.grantRead(edgeLambda.currentVersion);

    const distribution = new cloudfront.Distribution(this, "distribution", {
      defaultBehavior: {
        origin: new origins.S3Origin(bucket),
        cachePolicy: new cloudfront.CachePolicy(this, "cachePolicy", {
          maxTtl: cdk.Duration.seconds(1),
          minTtl: cdk.Duration.seconds(0),
          defaultTtl: cdk.Duration.seconds(0),
          // QueryStrings from pre-signed URL have to be forwarded to S3.
          queryStringBehavior: cloudfront.CacheQueryStringBehavior.all()
        }),
        edgeLambdas: [
          {
            eventType: cloudfront.LambdaEdgeEventType.VIEWER_REQUEST,
            functionVersion: edgeLambda.currentVersion,
            includeBody: false
          }
        ]
      }
    });
    urlLambda.addEnvironment("CF_DOMAIN", distribution.domainName);

    /**
     * I could not find any way to disable the default OAI created by `S3Origin` construct explicitly (through `S3Origin` options).
     * With OAI CloudFront adds the `Authorization` header (from my understand it's not possible to remove it using Lambda@Edge).
     * This header messes up the authorization part when pre-signed URL query strings  are forwarded to S3.
     *
     * The following lines remove the OAI created by `S3Origin` directly from the generated CloudFormation.
     */
    const cfnDistribution = distribution.node
      .defaultChild as cloudfront.CfnDistribution;

    cfnDistribution.addPropertyOverride(
      "DistributionConfig.Origins.0.S3OriginConfig.OriginAccessIdentity",
      ""
    );

    new cdk.CfnOutput(this, "assetsBucketName", { value: bucket.bucketName });

    new cdk.CfnOutput(this, "getPresignedUrlEndpoint", {
      value: `${api.apiEndpoint}/get-url`
    });
  }
}
